<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebAuthN Demo</title>
    <link href="/style.css" rel="stylesheet"/>
</head>
<body>

<div class="card">
    <div class="header">
        <h1>WebAuthN demo</h1>
    </div>
    <div class="content">
        <p>Your account:</p>
        <ul>
            <li>username: <span th:text="${username}"></span></li>
            <li>email: <span th:text="${email}"></span></li>
        </ul>

        <br>
        <h3>Existing Passkeys</h3>
        <ul>
            <li th:each="authenticator: ${authenticators}" th:text="${authenticator}"></li>
        </ul>

        <br>
        <h3>Register new passkey</h3>
        <input type="text" id="passkey-name"/>
        <button id="register-webauthn">Register</button>

        <br>
        <h3>Logout</h3>
        <a href="/logout">logout</a>
    </div>
</div>

</body>
<script th:inline="javascript">
    document.addEventListener("DOMContentLoaded", setup);

    function setVisibility(elmt, value) {
        // elmt.style.display = value ? 'block' : 'none'
    }

    const base64url = {
        encode: function (buffer) {
            const base64 = window.btoa(String.fromCharCode(...new Uint8Array(buffer)));
            return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
        },
        decode: function (base64url) {
            const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            const binStr = window.atob(base64);
            const bin = new Uint8Array(binStr.length);
            for (let i = 0; i < binStr.length; i++) {
                bin[i] = binStr.charCodeAt(i);
            }
            return bin.buffer;
        }
    }

    function setup() {
        const csrfToken = [[${_csrf.getToken()}]]
        const csrfHeaderName = [[${_csrf.getHeaderName()}]]
        const register = document.getElementById('register-webauthn');
        const success = document.getElementById('success');
        const error = document.getElementById('error');
        setVisibility(success, false)
        setVisibility(error, false)

        // Start registration when the user clicks a button
        register.addEventListener('click', async () => {
            // Reset success/error messages
            setVisibility(success, false)
            setVisibility(error, false)
            // success.innerHTML = '';
            // error.innerHTML = '';

            const label = document.getElementById('passkey-name').value
            if (!label) {
                setVisibility(error, true)
                // error.innerText = 'Error: Passkey Label is required'
                return;
            }

            const optionsResponse = await fetch('/webauthn/register/options', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    [csrfHeaderName]: csrfToken,
                },
            });
            const options = await optionsResponse.json();
            // FIXME: Use https://www.w3.org/TR/webauthn-3/#sctn-parseCreationOptionsFromJSON
            options.user.id = base64url.decode(options.user.id);
            options.challenge = base64url.decode(options.challenge);
            if (options.excludeCredentials) {
                for (let cred of options.excludeCredentials) {
                    cred.id = base64url.decode(cred.id);
                }
            }
            const credentialsContainer = await navigator.credentials.create({
                publicKey: options,
            });
            // FIXME: Let response be credential.response. If response is not an instance of AuthenticatorAttestationResponse, abort the ceremony with a user-visible error. https://www.w3.org/TR/webauthn-3/#sctn-registering-a-new-credential
            const {response} = credentialsContainer;
            const credential = {
                id: credentialsContainer.id,
                rawId: base64url.encode(credentialsContainer.rawId),
                response: {
                    attestationObject: base64url.encode(response.attestationObject),
                    clientDataJSON: base64url.encode(response.clientDataJSON),
                    transports: response.getTransports ? response.getTransports() : [],
                    publicKeyAlgorithm: response.getPublicKeyAlgorithm(),
                    publicKey: base64url.encode(response.getPublicKey()),
                    authenticatorData: base64url.encode(response.getAuthenticatorData()),
                },
                type: credentialsContainer.type,
                clientExtensionResults: credentialsContainer.getClientExtensionResults(),
                authenticatorAttachment: credentialsContainer.authenticatorAttachment,
            };

            const registrationRequest = {
                "publicKey": {
                    "credential": credential,
                    "label": label,
                }
            }
            const registrationRequestJSON = JSON.stringify(registrationRequest, null, 2)
            console.log(registrationRequestJSON)

            // POST the response to the endpoint that calls
            const verificationResp = await fetch('/webauthn/register', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    [csrfHeaderName]: csrfToken,
                },
                body: registrationRequestJSON,
            });

            // Wait for the results of verification
            const verificationJSON = await verificationResp.json();

            // Show UI appropriate for the `success` status & reload to display the new registration
            if (verificationJSON && verificationJSON.success) {
                window.location.href = '/account'
            } else {
                setVisibility(error, true)
                // error.innerHTML = `Registration failed! Response: <pre>${JSON.stringify(verificationJSON, null, 2)}</pre>`;
            }
        });
    }

    <!-- ⬇️ OLD GOES HERE-->
    // TODO: remove me
    function old() {
        async function registerPasskey() {
// Note: these options, specifically the challenge, should be generated at sign-in time, not page build time.
            const publicKeyCredentialCreationOptions = {
                challenge: Uint8Array.from(
                    "this-should-be-a-random-challenge-from-the-server", c => c.charCodeAt(0)),
                rp: {
                    name: "WebAuthN By Kehrlann",
                },
                user: {
                    id: Uint8Array.from(
                        [[${email}]], c => c.charCodeAt(0)),
                    displayName: [[${username}]],
                    name: [[${username}]]
                },
                pubKeyCredParams: [{alg: -7, type: "public-key"}],
                timeout: 60000,
                attestation: "direct",
                authenticatorSelection: {
                    requireResidentKey: false,
                    userVerification: "preferred",
// Cross-platform: Yubikey etc
// Platform: TouchID, Windows Hello, etc
// authenticatorAttachment: "cross-platform",
                },
            };
            const passkeyField = document.getElementById("passkey-name")
            const passkeyName = passkeyField.value
            passkeyField.value = ""
// TODO: if name missing, alert & abort

            const credentials = await navigator.credentials.create({
                publicKey: publicKeyCredentialCreationOptions
            });

            fetch("/passkey/register",
                {
                    method: "POST",
                    body: JSON.stringify({name: passkeyName, credentials: credentials}),
                    credentials: "same-origin",
                    headers: {
                        "Content-Type": "application/json;charset=utf-8"
                    },
                    redirect: "follow"
                })
                // Note: this is a hack, we should be using a form instead orr a REST response with a `Link: header`
                // Fetch downloads the redirect page, in the "then" we update the page and trigger a second download.
                // We lose the Spring Redirect Attributes during the first load, by the fetch, and so the banner does
                // not show up.
                .then(r => document.location.href = r.url)
                .catch(err => console.error(err))
                .finally(() => console.log("yep, done"));
        }


        document.getElementById("register-webauthn").addEventListener("click", async () => {
            await registerPasskey()
        })

        document.getElementById("passkey-name").addEventListener("keypress", async e => {
            if (e.key === 'Enter') {
                await registerPasskey()
            }
        })
    }
</script>
</html>