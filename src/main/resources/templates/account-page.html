<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebAuthN Demo</title>
</head>
<body>
<h1>Account page - <span th:text="${username}"></span></h1>
<div th:if="${alert != null}" th:text="${alert}"></div>
<p>Your information:</p>
<ul>
    <li>username: <span th:text="${username}"></span></li>
    <li>email: <span th:text="${email}"></span></li>
</ul>
<a href="/logout">logout</a>
<hr>
<h2>Existing Passkeys</h2>
<ul>
    <li th:each="authenticator: ${authenticators}">
        <form action="/passkey/delete" method="POST">
            <span th:text="${authenticator.getCredentialsName()}"></span>
            <input type="hidden" name="credential-id" th:value="${authenticator.getId()}"/>
            <input type="hidden" th:name="${_csrf.getParameterName()}" th:value="${_csrf.getToken()}"/>
            <button type="submit" class="inline">Delete</button>
        </form>
    </li>
</ul>
<h2>Register new passkey</h2>
<label for="passkey-name">Passkey name</label>
<input type="text" id="passkey-name"/>
<button id="register-webauthn">Register</button>
</body>
<script th:inline="javascript">
    // TODO: note, these keys should be generated at sign-in time, not page build time.
    const publicKeyCredentialCreationOptions = {
        challenge: Uint8Array.from(
            [[${challenge}]], c => c.charCodeAt(0)),
        rp: {
            name: "WebAuthN By Kehrlann",
            // TODO: clarify
            // id: "webauthn.garnier.wf",
            id: "localhost"
        },
        user: {
            id: Uint8Array.from(
                [[${username}]], c => c.charCodeAt(0)), // TODO: a "real" ID
            displayName: [[${username}]],
            name: [[${username}]]
        },
        pubKeyCredParams: [{alg: -7, type: "public-key"}],
        // Cross-platform: Yubikey etc
        // Platform: TouchID, Windows Hello, etc
        // authenticatorSelection: {
        //     authenticatorAttachment: "cross-platform",
        // },
        timeout: 60000,
        attestation: "direct",
        authenticatorSelection: {
            requireResidentKey: false,
            userVerification: "preferred"
        },
    };

    document.getElementById("register-webauthn").addEventListener("click", async () => {
        const passkeyField = document.getElementById("passkey-name")
        const passkeyName = passkeyField.value
        passkeyField.value = ""
        // TODO: if name missing, alert & abort

        const credentials = await navigator.credentials.create({
            publicKey: publicKeyCredentialCreationOptions
        });
        // TODO: hack ðŸ˜±ðŸ˜±ðŸ˜±
        const parsedResponse = JSON.parse(JSON.stringify(credentials))
        fetch("/passkey/register",
            {
                method: "POST",
                body: JSON.stringify({response: parsedResponse.response, id: parsedResponse.id, name: passkeyName}),
                credentials: "same-origin",
                headers: {
                    [[${_csrf.headerName}]]: [[${_csrf.token}]],
                    "Content-Type": "application/json;charset=utf-8"
                },
                redirect: "follow"
            })
            // TODO: this is a hack, we should be using a form instead
            // Or a REST response with a Link: header
            // It loses Redirect Attributes becaues the page is loaded by the fetch, and then by the
            // navigate
            .then(r => document.location.href = r.url)
            .catch(err => console.error(err))
            .finally(() => console.log("yep, done"));
    })
</script>
</html>